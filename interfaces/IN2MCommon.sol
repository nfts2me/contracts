/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                Smart contract generated by https://nfts2me.com                //
 *                                                                               //
 *                                      .::.                                     //
 *                                    ......                                     //
 *                                ....        ::.                                //
 *                             .:..           :: ...                             //
 *                         ..:.               ::     ...                         //
 *                       ::.      ..:--       ::.       ...                      //
 *                      .:    ..:::::-==:     :::::..     :                      //
 *                      .:    :::::::-====:   ::::::::    :                      //
 *                      .:    :::::::-======. ::::::::    :                      //
 *                      .:    :::::::-=======-::::::::    :                      //
 *                      .:    :::::::-========-:::::::    :                      //
 *                      .:    ::::::::========-:::::::    :                      //
 *                      .:    :::::::. .======-:::::::    :                      //
 *                      .:    :::::::.   :====-:::::::    :                      //
 *                      .:     .:::::.     -==-:::::.     :                      //
 *                       .:.       .:.      .--:..      ...                      //
 *                          .:.     :.               ...                         //
 *                             .... :.           ....                            //
 *                                 .:.        .:.                                //
 *                                      .::::.                                   //
 *                                      :--.                                     //
 *                                                                               //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 *   More info at: https://docs.nfts2me.com/                                     //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {IERC2981} from "openzeppelin/contracts/interfaces/IERC2981.sol";
import {IERC4907} from "./IERC4907.sol";
import {IERC5192} from "./IERC5192.sol";
import {IERC7496} from "./IERC7496.sol";
import {IERC7572} from "./IERC7572.sol";
import {IN2MCommonStorage} from "./IN2MCommonStorage.sol";

interface IN2MCommon is IN2MCommonStorage, IERC2981, IERC4907, IERC5192, IERC7496, IERC7572 {
    /// @notice This event is emitted when a token is minted using an affiliate
    /// @param affiliate The affiliate address
    event AffiliateSell(address indexed affiliate);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    event BatchMetadataUpdate(uint256 fromTokenId, uint256 toTokenId);

    event ImmutableTrait(bytes32 indexed traitKey, uint256 indexed tokenId, bytes32 value);

    /// @notice Error thrown when input variable differ in length
    error InvalidInputSizesDontMatch();

    /// @notice Error thrown when trying to mint a token with a given invalid id
    error InvalidTokenId();

    /// @notice Error thrown when the input amount is not valid
    error InvalidAmount();

    /// @notice Error thrown when trying to mint a sold out collection or the amount to mint exceeds the remaining supply
    error CollectionSoldOut();

    /// @notice Error thrown when trying to presale/whitelist mint and the collection current phase is `closed`
    error PresaleNotOpen();

    /// @notice Error thrown when trying to mint and the collection current phase is not `open`
    error PublicSaleNotOpen();

    /// @notice Error thrown when trying to mint but the sale has already finished
    error SaleFinished();

    /// @notice Error thrown when trying to mint more than the allowance to mint
    error NotEnoughAmountToMint();

    /// @notice Error thrown when the sent amount is not valid
    error InvalidMintFee();

    /// @notice Invalid input. Total supply must be greater than zero
    error InvadlidCollectionSize();

    /// @notice Can't transfer a Soulbound Token (SBT)
    error NonTransferrableSoulboundNFT();

    /// @notice The input revenue percentages are not valid
    error InvalidRevenuePercentage();

    /// @notice Can't mint until specified drop date
    error WaitUntilDropDate();

    /// @notice Trying to use mintPresale method in a collection with a minting type that doesn't support whitelist
    error PresaleInvalidMintingType();

    /// @notice Metadata is already fixed. Can't change metadata once fixed
    error MetadataAlreadyFixed();

    /// @notice Invalid collection minting type for the current minting function
    error InvalidMintingType();

    /// @notice The address exceeded the max per address amount
    error MaxPerAddressExceeded();

    /// @notice The given signature doesn't match the input values
    error SignatureMismatch();

    /// @notice The given signature is not valid
    error InvalidSignature();

    /// @notice Reentrancy Guard protection
    error ReentrancyGuard();

    /// @notice New BaseURI can't be empty
    error NewBaseURICantBeEmpty();    

    /// @notice Invalid percentage or discount values
    error InvalidPercentageOrDiscountValues();

    /// @notice Can't lower current percentages
    error CantLowerCurrentPercentages();

    /// @notice Invalid phase can't be set without giving a date, use the proper functions
    error InvalidPhaseWithoutDate();

    /// @notice Payment address can't be changed if there is pending affiliate balance to withdraw.
    error PendingAffiliatesBalance();

    /// @notice Operator not allowed
    error OperatorNotAllowed(address operator);

    /// @notice Error indicating that the minter is not allowlisted
    error NotAllowlisted();

    /// @notice The initialization has already been done
    error InvalidInitialization();

    /// @notice Error indicating that the trait is not editable more than once
    error OnlyOnceTrait();

    /// @notice Trait is not editable by the token owner
    error NonEditableTraitByTokenOwner();

    /// @notice Error indicating that the caller is not the owner of the contract or an authorized account
    error OwnableUnauthorizedAccount(address account);

    /// @notice Error indicating that the metadata cannot be frozen when setting a placeholder
    error PlacerholderCantFreezeMetadata();

    /// @notice The caller must own the token or be an approved operator.
    error ApprovalCallerNotOwnerNorApproved();

    /// @notice The token does not exist.
    error ApprovalQueryForNonexistentToken();

    /// @notice Cannot query the balance for the zero address.
    error BalanceQueryForZeroAddress();

    /// @notice Cannot mint to the zero address.
    error MintToZeroAddress();

    /// @notice The quantity of tokens minted must be more than zero.
    error MintZeroQuantity();

    /// @notice The token does not exist.
    error OwnerQueryForNonexistentToken();

    /// @notice The caller must own the token or be an approved operator.
    error TransferCallerNotOwnerNorApproved();

    /// @notice The token must be owned by `from`.
    error TransferFromIncorrectOwner();

    /// @notice Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.
    error TransferToNonERC721ReceiverImplementer();

    /// @notice Cannot transfer to the zero address.
    error TransferToZeroAddress();

    /// @notice The caller must own the token or be an approved operator.
    error TransferFromFailed();

    /// @notice Initializer for the contract
    function initialize008joDSK
    (
        string calldata name,
        string calldata symbol,
        uint256 mintPrice,
        bytes32 baseURIorPlaceholderCIDHash,
        bytes32 packedData,
        bytes calldata extraCollectionInformation
    ) external payable;

    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string memory);

    /// @notice An abbreviated name for NFTs in this contract
    /// @return the collection symbol
    function symbol() external view returns (string memory);

    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.
    /// @param toWihtExtra To address packed with extra information.
    /// @param customFee Zero is fee is different from `mintingPrice`.
    /// @param signature Valid `signature` for the presale/whitelist.
    function mintWhitelist(
        bytes32 toWihtExtra,
        uint256 customFee,
        bytes calldata signature,
        uint256[] calldata tokenIds) payable external;

    /// @notice returns the merkle root of the current whitelist
    function merkleRoot() external view returns (bytes32);

    /// @notice sets the merkle root for the current whitelist
    function setMerkleRoot(bytes32 merkleRoot_) external payable;

    /// @notice returns 'true' if the given address is allowlisted
    function allowListed(address _wallet, bytes32[] calldata _proof) external view returns (bool);

    /// @notice mint `amount` of NFTs if the msg.sender is allowlisted
    function mintAllowlist(uint256 amount, bytes32[] calldata _proof) external payable;

    /// @notice Returns the minting fee of `amount` NFT.
    /// @return Mint price for `amount` NFTs in native coin or ERC-20.
    function mintFee(uint256 amount) external view returns (uint256);

    /// @notice Returns the platform fee of one NFT.
    /// @return Platform for one NFT in native coin.
    function protocolFee() external view returns (uint256);

    /// @notice Returns the current total supply.
    /// @return Current total supply.
    function totalSupply() external view returns (uint256);

    /// @notice Max amount of NFTs to be hold per address.
    /// @return Max per address allowed.
    function maxPerAddress() external view returns (uint256);

    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.
    function isMetadataFixed() external view returns (bool);

    function setBaseURI(string memory baseURIString, bytes32 baseURICIDHash, bool isPlaceholder, bool freezeMetadata) external payable;
    function changeMintFee(uint256 newMintFee, bool isDynamic) external payable;
    function contractURI() external view returns (string calldata);
    function setContractURI(bytes32 newContractURIMetadataCIDHash) external payable;
    function setAffiliatesPercentageAndDiscount(uint16 userDiscount, uint16 affiliatePercentage, address affiliateAddress) external;
    function affiliateWithdraw(address affiliate) external payable;
    function withdrawERC20(address erc20Address) external payable;
    function withdraw() external payable;
    function setPhase(SalePhase newPhase) external payable;
    function setDropAndEndDate(uint256 dropDateTimestamp, uint256 endDateTimestamp) external payable;
    function setMaxPerAddress(uint16 newMaxPerAddress) external payable;
    function isOperatorFilterRegistryEnabled() external view returns (bool);
    function whitelistOperators(address[] calldata operators) external payable;
    function disableOperatorFilterRegistry() external payable;
    function reserveTokens(uint16 amount) external payable;
    function unreserveTokens(uint16 amount) external payable;
    function reservedTokens() external view returns (uint256);
    function collectionSize() external view returns (uint256);
    function affiliatesInfo(address affiliate) external view returns (bool enabled, uint16 affiliatePercentage, uint16 userDiscount);
    function changeRoyaltyFee(uint16 newFee) external payable;
    function royaltyFee() external view returns (uint256);
    function changeERC20PaymentAddress(address newErc20PaymentAddress) external payable;
    function currentPhase() external view returns (SalePhase);
    function mintingType() external view returns (MintingType);
    function saleDates() external view returns (uint256 dropDateTimestamp, uint256 endDateTimestamp);
    function isOpen() external view returns (bool);
    function ownershipTransferred(address from, address to) external payable;
    function ownerMaxRevenue() external view returns (uint256);
    function removeProtocolFee(bytes calldata signature, uint256 fee, address feeReceiver) external payable;
    function setTraitsPermissions(bytes32[] calldata ownerCanUpdateTraitKeys, bytes32[] calldata notOnlyOnceTraitKeys) external payable;
    function setTraitMetadataURI(string calldata uri) external payable;
    function withdrawnAmount() external view returns (uint256);
    function pendingTotalAffiliatesBalance() external view returns (uint256);
    function erc20PaymentAddress() external view returns (address);
    function owner() external view returns (address collectionOwner);
    function transferOwnership(address to) external payable;
    function reduceCollectionSize(uint32 newCollectionSize) external payable;

}
