/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                                       .:::.                                   //
 *                                    .:::::::.                                  //
 *                                    ::::::::.                                  //
 *                                 .:::::::::.                                   //
 *                             ..:::.              ..                            //
 *                          .::::.                 ::::..                        //
 *                      ..:::..                    ::::::::.                     //
 *                   .::::.                        :::.  ..:::.                  //
 *               ..:::..                           :::.      .:::.               //
 *            .::::.                               :::.         .:::..           //
 *         .:::..               ..                 :::.            .::::.        //
 *     .::::.               ..:::=-                ::::               ..:::.     //
 *    :::.               .:::::::===:              ::::::.               .::::   //
 *   .::.            .:::::::::::=====.            ::::::::::.             .::.  //
 *   .::         .:::::::::::::::=======.          :::::::::::::..          ::.  //
 *   .::        .::::::::::::::::========-         :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==========:       :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::============:     :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==============.   :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::===============-. :::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::=================::::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::==================-::::::::::::::::        ::.  //
 *   .::        .:::::::::::::::::=================-::::::::::::::::        ::.  //
 *   .::        .:::::::::::::::: .-===============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::   .==============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::     :============-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::       :==========-::::::::::::::::        ::.  //
 *   .::        .::::::::::::::::        .-========-::::::::::::::::        ::.  //
 *   .::          .::::::::::::::          .=======-::::::::::::::.         ::.  //
 *   .::.             .::::::::::            .=====-::::::::::..            ::.  //
 *    :::..              ..::::::              :===-::::::..              .:::.  //
 *      .:::..               .:::                -=-:::.               .::::.    //
 *         .::::.            .:::                 ..                .::::.       //
 *            .::::.         .:::                               ..:::.           //
 *                .:::.      .:::                            .::::.              //
 *                   .:::..  .:::                        ..:::..                 //
 *                      .::::.:::                     .::::.                     //
 *                         ..::::                 ..:::..                        //
 *                             .:              .::::.                            //
 *                                     :::::.::::.                               //
 *                                    ::::::::.                                  //
 *                                    :::::::.                                   //
 *                                     .::::.                                    //
 *                                                                               //
 *                                                                               //
 *   Smart contract generated by https://nfts2me.com                             //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "../openzeppelin-contracts-upgradeable/interfaces/IERC2981Upgradeable.sol";
import "../important/README.sol";

interface IN2M_ERCCommon is IERC2981Upgradeable, Readme {
    /// @notice This event is emitted when a token is minted using an affiliate
    /// @param affiliate The affiliate address
    event AffiliateSell(address indexed affiliate);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    /// @notice Error thrown when trying to mint a token with a given id which is already minted
    error TokenAlreadyMinted();

    /// @notice Error thrown when input variable differ in length
    error InvalidInputSizesDontMatch();

    /// @notice Error thrown when input variable differ in length
    error InputSizeMismatch();

    /// @notice Error thrown when trying to mint a token with a given invalid id
    error InvalidTokenId();

    /// @notice Error thrown when trying to redeem random tickets with no amount to redeem
    error NothingToRedeem();

    /// @notice Error thrown when trying to redeem random tickets too soon
    error CantRevealYetWaitABitToBeAbleToRedeem();

    /// @notice Error thrown when the input amount is not valid
    error InvalidAmount();

    /// @notice Error thrown when trying to mint a sold out collection or the amount to mint exceeds the remaining supply
    error CollectionSoldOut();

    /// @notice Error thrown when trying to presale/whitelist mint and the collection current phase is `closed`
    error PresaleNotOpen();

    /// @notice Error thrown when trying to mint and the collection current phase is not `open`
    error PublicSaleNotOpen();

    /// @notice Error thrown when trying to mint but the sale has already finished
    error SaleFinished();

    /// @notice Error thrown when trying to mint more than the allowance to mint
    error NotEnoughAmountToMint();

    /// @notice Error thrown when sending funds to a free minting
    error InvalidMintFeeForFreeMinting();

    /// @notice Error thrown when the sent amount is not valid
    error InvalidMintFee();

    /// @notice Royalty fee can't be higher than 10%
    error RoyaltyFeeTooHigh();

    /// @notice Invalid input. Total supply must be greater than zero
    error InvadlidCollectionSize();

    /// @notice Can't set BaseURI and Placeholder at the same time
    error CantSetBaseURIAndPlaceholderAtTheSameTime();

    /// @notice No BaseURI nor Placeholder set
    error NoBaseURINorPlaceholderSet();

    /// @notice Can't transfer a Soulbound Token (SBT)
    error NonTransferrableSoulboundNFT();

    /// @notice The input revenue percentages are not valid
    error InvalidRevenuePercentage();

    /// @notice Can't mint until specified drop date
    error WaitUntilDropDate();

    /// @notice Trying to use mintPresale method in a collection with a minting type that doesn't support whitelist
    error PresaleInvalidMintingType();

    /// @notice Metadata is already fixed. Can't change metadata once fixed
    error MetadataAlreadyFixed();

    /// @notice Invalid collection minting type for the current minting function
    error InvalidMintingType();

    /// @notice The address exceeded the max per address amount
    error MaxPerAddressExceeded();

    /// @notice The given signature doesn't match the input values
    error SignatureMismatch();

    /// @notice Reentrancy Guard protection
    error ReentrancyGuard();

    /// @notice New Placeholder can't be empty
    error NewPlaceholderCantBeEmpty();

    /// @notice New BaseURI can't be empty
    error NewBaseURICantBeEmpty();    

    /// @notice Invalid percentage or discount values
    error InvalidPercentageOrDiscountValues();

    /// @notice Can't lower current percentages
    error CantLowerCurrentPercentages();

    /// @notice Contract MetadataURI already fixed
    error ContractMetadataURIAlreadyFixed();

    /// @notice Only owner of N2M can call this function
    error OnlyOwnerOrN2M();

    /// @notice Only the given affiliate or N2M can call this function
    error OnlyAffiliateOrN2M();

    /// @notice The signature has expired
    error SignatureExpired();

    /// @notice Invalid phase can't be set without giving a date, use the proper functions
    error InvalidPhaseWithoutDate();

    /// @notice Invalid drop date
    error InvalidDropDate();

    /// @notice Operator address is filtered
    error AddressFiltered(address filtered);

    /// @notice Payment address can't be changed if there is pending affiliate balance to withdraw.
    error PendingAffiliatesBalance();

    error OperatorNotAllowed(address operator);

    error OnlyFactory();

    enum TokenUriType {
        BASE_URI_CID,
        PLACEHOLDER_CID,
        BASEURI_STRING,
        DYNAMIC_NFT
    }

    struct ExtraCollectionInformation {
        address erc20PaymentAddress;
        MintingType mintingType;
        bool soulboundCollection;
        TokenUriType uriType;
        address dynamicNFTAddress;
        address dynamicPriceAddress;
        string baseURIOrPlaceholderString;
        RevenueAddress[] revenueAddresses;
        uint256[] dropAndEndDateTimestamps;
        SalePhase initPhase;
    }

    struct InitParams {
        string tokenName;
        string tokenSymbol;
        uint256 mintPrice;
        RevenueAddress[] revenueAddresses;
        bytes32 baseURIorPlaceholderCIDHash;
        uint32 totalSupply;
        uint16 royaltyFee;
        bool cidIsPlaceholder;
        bool soulboundCollection;
        SalePhase initPhase;
        MintingType mintingType;
        address erc20PaymentAddress;

        // Falta aquí el extra
        // extra de string URI
        // extra de dynamic NFT
        bytes extraInformation;
    }

    struct RandomTicket {
        uint256 amount;
        uint256 blockNumberToReveal;
    }

    struct RevenueAddress {
        address to;
        uint16 percentage;
    }

    struct AffiliateInformation {
        bool enabled;
        uint16 affiliatePercentage;
        uint16 userDiscount;
    }

    enum SalePhase { 
        PUBLIC,
        CLOSED,
        PRESALE,
        DROP_DATE,
        DROP_AND_END_DATE
    }

    enum MintingType { 
        SEQUENTIAL, 
        RANDOM,
        SPECIFY, 
        CUSTOM_URI,
        RESERVED1,
        RESERVED2,
        RESERVED3,
        SEQUENTIAL_OPEN_EDITION // NOT REAL MINTING TYPE. JUST FOR INTERNAL USE
    }

    enum OperatorFilterStatus { 
        DISABLED, 
        ENABLED_ONLY_WHITELISTED
    }

    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.
    function isMetadataFixed() external view returns (bool);



    /// @notice Returns the address of the current collection owner.
    /// @return The address of the owner.
    function owner() external view returns (address);

    /// @notice To be called to create the collection. Can only be called once.
    function initialize
    (
        string memory tokenName,
        string memory tokenSymbol,
        uint256 iMintPrice,
        bytes32 baseURIorPlaceholderCIDHash,
        uint32 iTotalSupply,
        uint16 iRoyaltyFee,
        address initialOwner,
        bytes calldata extraCollectionInformation
    ) external payable;

    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string memory);

    /// @notice An abbreviated name for NFTs in this contract
    /// @return the collection symbol
    function symbol() external view returns (string memory);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 tokenId) external view returns (string memory);

    /// @notice Mints one NFT to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    function mint() external payable;

    /// @notice Mints `amount` NFTs to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param amount The number of NFTs to mint
    function mint(uint256 amount) external payable;

    /// @notice Mints `amount` NFTs to the caller (msg.sender) with a given `affiliate`. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param amount The number of NFTs to mint
    /// @param affiliate The affiliate address
    function mint(uint256 amount, address affiliate) external payable;

    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    function mintTo(address to, uint256 amount) external payable;

    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    /// @param affiliate The affiliate address
    function mintTo(address to, uint256 amount, address affiliate) external payable;

    /// @notice One step on-chain random minting. Mints `amount` NFTs to `to` address. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// Note: it is not real on-chain random minting, as the result may be influenced by miners or other techniques, so not real 100% random.
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    function mintRandomTo(address to, uint256 amount) external payable;    

    /// @notice One step on-chain random minting. Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// Note: it is not real on-chain random minting, as the result may be influenced by miners or other techniques, so not real 100% random.
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    /// @param affiliate The affiliate address
    function mintRandomTo(address to, uint256 amount, address affiliate) external payable;

    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    function mintSpecifyTo(address to, uint256[] memory tokenIds) external payable; 

    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    /// @param affiliate The affiliate address
    function mintSpecifyTo(address to, uint256[] memory tokenIds, address affiliate) external payable; 

    /// @notice Mints one NFT to `to` address. Requires `minting type` to be `customURI`.
    /// @param to The address of the NFTs receiver
    /// @param customURICIDHash The CID of the given token.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function mintCustomURITo(address to, bytes32 customURICIDHash, bool soulbound) external payable;

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses. Requires `minting type` to be `sequential`.
    /// @param to The addresses of the NFTs receivers
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSequential(address[] memory to, bool soulbound) external payable;

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with random tokenIds. Requires `minting type` to be `random`.
    /// @param to The addresses of the NFTs receivers
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropRandom(address[] memory to, bool soulbound) external payable;

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with specified tokenIds. Requires `minting type` to be `specify`.
    /// @param to The addresses of the NFTs receivers
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSpecify(address[] memory to, uint256[] memory tokenIds, bool soulbound) external payable;

    function airdropCustomURI(address[] memory to, bytes32[] memory customURICIDHash, bool soulbound) external payable;

    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.
    /// @param to The addresses of the NFTs receivers
    /// @param tokenIds An optional array of the specified tokens. They must not be minted, otherwise, it will revert. Only used if minting type is `specify`.
    /// @param freeMinting True is minting is free
    /// @param customFee Zero is fee is different from `mintingPrice`.
    /// @param maxAmount Max Amount to be minted with the given `signature`.
    /// @param amount Amount to mint.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    /// @param signature Valid `signature` for the presale/whitelist.
    function mintPresale (
        address to, 
        uint256[] memory tokenIds,
        bool freeMinting, 
        uint256 customFee, 
        uint256 maxAmount,
        uint256 amount, 
        bool soulbound,
        bytes calldata signature) payable external;

    /// @notice Returns the minting price of one NFT.
    /// @return Mint price for one NFT in native coin or ERC-20.
    function mintPrice() external view returns (uint256);

    /// @notice Returns the current total supply.
    /// @return Current total supply.
    function totalSupply() external view returns (uint256);

    /// @notice Max amount of NFTs to be hold per address.
    /// @return Max per address allowed.
    function maxPerAddress() external view returns (uint16);

    
    function setAndRevealBaseURI(bytes32 baseURICIDHash) external payable;
    function setAndRevealBaseURIString(string memory baseURIString) external payable;
    function changeMintPrice(uint256 newMintPrice) external;
    function contractURI() external view returns (string memory);
    function setContractURI(bytes32 newContractURIMetadataCIDHash) external;
    function setAffiliatesPercentageAndDiscount(uint16 userDiscount, uint16 affiliatePercentage, address affiliateAddress) external;
    function affiliateWithdraw(address affiliate) external;
    function withdrawERC20(address erc20Address) external;
    //function withdrawERC20Pro(uint256 signatureExpireDate, uint n2mFee, address erc20Address, bytes calldata signature) external;
    function withdraw() external payable;
    //function withdrawPro(uint256 signatureExpireDate, uint256 n2mFee, bytes calldata signature) external;
    // function setReverseENSName(address rerverseResolver, string calldata collectionENSName) external;
    // function initializeAndSetReverseENSName(address resolver, string calldata collectionENSName) external;
    function changePlaceholderImageCID(bytes32 newPlaceholderImageCIDHash) external payable;
    function setPhase(SalePhase newPhase) external payable;
    function setDropDate(uint256 dropDateTimestamp) external payable;
    function setDropAndEndDate(uint256 dropDateTimestamp, uint256 endDateTimestamp) external payable;
    function setMaxPerAddress(uint16 newMaxPerAddress) external payable;
    function reduceCollectionSize(uint32 newCollectionSize) external payable;
    function isOperatorFilterRegistryEnabled() external view returns (bool);
    // function enableOperatorFilterRegistry() external payable;
    function disableOperatorFilterRegistry() external payable;
    function collectionSize() external view returns (uint256);
    function affiliatesInfo(address affiliate) external view returns (bool enabled, uint16 affiliatePercentage, uint16 userDiscount);
    function pendingAffiliateBalance(address affiliate) external view returns (uint256);
    function pendingTotalAffiliatesBalance() external view returns (uint256);
    function changeRoyaltyFee(uint16 newFee) external payable;
    function royaltyFee() external view returns (uint256);
    function withdrawnAmount() external view returns (uint256);
    function withdrawnERC20Amount(address erc20) external view returns (uint256);
    function changeERC20PaymentAddress(address newErc20PaymentAddress) external payable;
    function erc20PaymentAddress() external view returns (address);
    function currentPhase() external view returns (SalePhase);
    function mintingType() external view returns (MintingType);
    function saleDates() external view returns (uint256 dropDateTimestamp, uint256 endDateTimestamp);
    function isOpen() external view returns (bool);
    function transferOwnership(address from, address to) external payable;
    function ownerMaxRevenue() external view returns (uint256);
    function removeFees(bytes calldata signature) external payable;


}

