/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                Smart contract generated by https://nfts2me.com                //
 *                                                                               //
 *                                      .::.                                     //
 *                                    ......                                     //
 *                                ....        ::.                                //
 *                             .:..           :: ...                             //
 *                         ..:.               ::     ...                         //
 *                       ::.      ..:--       ::.       ...                      //
 *                      .:    ..:::::-==:     :::::..     :                      //
 *                      .:    :::::::-====:   ::::::::    :                      //
 *                      .:    :::::::-======. ::::::::    :                      //
 *                      .:    :::::::-=======-::::::::    :                      //
 *                      .:    :::::::-========-:::::::    :                      //
 *                      .:    ::::::::========-:::::::    :                      //
 *                      .:    :::::::. .======-:::::::    :                      //
 *                      .:    :::::::.   :====-:::::::    :                      //
 *                      .:     .:::::.     -==-:::::.     :                      //
 *                       .:.       .:.      .--:..      ...                      //
 *                          .:.     :.               ...                         //
 *                             .... :.           ....                            //
 *                                 .:.        .:.                                //
 *                                      .::::.                                   //
 *                                      :--.                                     //
 *                                                                               //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 *   More info at: https://docs.nfts2me.com/                                     //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.25;

import {IERC7496, IERC5192, ECDSA, Common, N2MCommonStorage, IN2MCommon, DynamicNFT, DynamicPrice} from "../Common.sol";
import {IN2MCrossFactory} from "../interfaces/IN2MCrossFactory.sol";
import {IN2MSequential} from "../interfaces/IN2MSequential.sol";

/// @title NFTs2Me.com Smart Contracts
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact security@nfts2me.com
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
abstract contract ConsecutiveMinting is Common, IN2MSequential {
    function initialize008joDSK(
        string calldata name_,
        string calldata symbol_,
        uint256 mintPrice_,
        bytes32 baseURICIDHash,
        bytes32 packedData,
        bytes calldata extraCollectionInformation
    ) public payable override initializer {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = 1;

        if (mintPrice_ > 0) _mintPrice = mintPrice_;

        uint32 collectionSize_ = uint32(uint256(packedData) >> _BITPOS_INIT_COLLECTION_SIZE);
        if (collectionSize_ == 0) _availableCollectionSize = type(uint32).max;
        else _availableCollectionSize = collectionSize_;

        _royaltyFee = uint16(uint256(packedData) >> _BITPOS_INIT_ROYALTY_FEE);

        if (MintingType(uint8(uint256(packedData) >> _BITPOS_INIT_MINTING_TYPE)) == MintingType.SEQUENTIAL_EDITIONS) {
            _isEditions = true;
        }

        if (baseURICIDHash != bytes32(0)) _baseURICIDHash = baseURICIDHash;
        uint256 extraCollectionInformationLength = extraCollectionInformation.length;
        if (extraCollectionInformationLength > 0) {

            uint8 bitmap = uint8(uint256(packedData) >> _BITPOS_INIT_BITMAP);

            bool isSoulbound = (bitmap & BIT1MASK) != 0;
            bool hasPlaceholder = (bitmap & BIT2MASK) != 0;
            bool hasDynamicPrice = (bitmap & BIT3MASK) != 0;
            bool hasEditableMetadata = bitmap & BIT4MASK != 0;
            uint16 reservedTokens_ = uint16(uint256(packedData) >> _BITPOS_INIT_RESERVED_TOKENS);

            if (isSoulbound) {
                _soulboundCollection = true;
            }

            if (hasPlaceholder) {
                _hasPlaceholder = true;
                _isMetadataEditable = true;
            }

            if (hasEditableMetadata) {
                _isMetadataEditable = true;
            }

            if (hasDynamicPrice) {
                _hasDynamicPrice = true;
            }

            if (reservedTokens_ > 0) {

                _reservedTokens = reservedTokens_;
                if (_actualCollectionSize() > type(uint32).max) _revert(InvadlidCollectionSize.selector);
            }

            if (extraCollectionInformationLength > 1) {

                bool hasStrings = bitmap & BIT5MASK != 0;
                bool hasDynamicNFTAddress = bitmap & BIT6MASK != 0;
                bool hasERC20PaymentAddress = bitmap & BIT7MASK != 0;
                bytes32[] memory bArray;

                if (hasStrings) {

                    string memory baseURIString_;
                    string memory collectionDescription_;
                    (bArray, baseURIString_, collectionDescription_) = abi.decode(extraCollectionInformation, (bytes32[], string, string));
                    if (bytes(baseURIString_).length > 0) _baseURIString = baseURIString_;
                    if (bytes(collectionDescription_).length > 0) _collectionDescription = collectionDescription_;
                } else {
                    (bArray) = abi.decode(extraCollectionInformation, (bytes32[]));
                }

                uint256 index;
                SalePhase initPhase = SalePhase(uint8(uint256(packedData >> _BITPOS_INIT_PHASE)));
                if (initPhase != SalePhase.PUBLIC) {
                    _currentPhase = initPhase;

                    if (initPhase > SalePhase.PRESALE) {
                        _dropDateTimestamp = uint256(bArray[index++]);
                        _endDateTimestamp = uint256(bArray[index++]);
                    }
                }

                if (hasDynamicNFTAddress) {
                    _isDynamicNFT = true;
                    _dynamicNFT = DynamicNFT(address(uint160(uint256(bArray[index++]))));
                }

                if (hasERC20PaymentAddress) {
                    _isERC20Payment = true;
                    _erc20PaymentAddress = address(uint160(uint256(bArray[index++])));
                }

                uint256 revenuePercentageTotal;
                for (uint256 bArrayLength = bArray.length; index < bArrayLength; index++) {
                    uint256 revenueInfo = uint256(bArray[index]);
                    uint16 percentage = uint16(revenueInfo >> 160);
                    revenuePercentageTotal += percentage;
                    _revenueInfo.push(RevenueAddress(address(uint160(revenueInfo)), percentage));
                }
                if (revenuePercentageTotal > 100_00) revert InvalidRevenuePercentage();
            }
        }

        emit OwnershipTransferred(address(0), address(uint160(uint256(packedData))));
    }

    /// @notice Mints one NFT to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    function mintEfficientN2M_001Z5BWH() external payable override {
        _requireFeesPayment(_creatorMintFee(), _protocolFee());
        _checkPhase();
        if (_nextTokenId() > _availableCollectionSize) revert CollectionSoldOut();
        __mint(msg.sender, 1);
    }

    /// @notice Mints one NFT to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    function mint() external payable override {
        _requireFeesPayment(_creatorMintFee(), _protocolFee());
        _checkPhase();
        if (_nextTokenId() > _availableCollectionSize) revert CollectionSoldOut();
        __mint(msg.sender, 1);
    }

    /// @notice Mints `amount` NFTs to the caller (msg.sender). Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param amount The number of NFTs to mint
    function mint(uint256 amount) external payable override {
        _requireFee(amount);
        _mintSequentialWithChecks(msg.sender, amount);
    }

    /// @notice Mints `amount` NFTs to the caller (msg.sender) with a given `affiliate`. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param amount The number of NFTs to mint
    /// @param affiliate The affiliate address
    function mint(uint256 amount, address affiliate) external payable override {
        _requirePaymentWithAffiliates(amount, affiliate);
        _mintSequentialWithChecks(msg.sender, amount);
    }

    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    function mintTo(address to, uint256 amount) external payable override {
        _requireFee(amount);
        _mintSequentialWithChecks(to, amount);
    }

    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `sequential` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    /// @param affiliate The affiliate address
    function mintTo(address to, uint256 amount, address affiliate) external payable override {
        _requirePaymentWithAffiliates(amount, affiliate);
        _mintSequentialWithChecks(to, amount);
    }

    function _mintSequentialWithChecks(address to, uint256 amount) private {
        _checkPhase();
        if ((_actualSoldTokens() + amount) > _availableCollectionSize) revert CollectionSoldOut();

        _mintSequential(to, amount);
    }

    function _mintSequential(address to, uint256 amount, bool soulbound) private {
        if (soulbound && !_soulboundCollection) {
            for (uint256 i = 0; i < amount; i++) {
                _soulbound[_nextTokenId() + i] = true;
            }
        }
        _mintSequential(to, amount);
    }

    function _mintSequential(address to, uint256 amount) internal virtual {
        __mint(to, amount);
    }

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses. Requires `minting type` to be `sequential`.
    /// @param toAndAmount The addresses and amounts of the NFTs receivers
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSequential(bytes32[] calldata toAndAmount, bool soulbound)
        external
        payable
        override
        onlyOwner
    {
        uint256 toLength = toAndAmount.length;

        for (uint256 i = 0; i < toLength; i++) {
            address to = address(uint160(uint256(toAndAmount[i])));
            uint256 amount = uint256(toAndAmount[i] >> 160);
            _mintSequential(to, amount, soulbound);
        }

        if (_actualSoldTokens() > _availableCollectionSize) revert CollectionSoldOut();
    }

    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.
    /// @param toWihtExtra To address packed with extra information.
    /// @param customFee Zero is fee is different from `mintingPrice`.
    /// @param signature Valid `signature` for the presale/whitelist.
    function mintWhitelist(
        bytes32 toWihtExtra,
        uint256 customFee,
        bytes calldata signature,
        uint256[] calldata tokenIds
    ) external payable override {

        uint16 amount = uint16(uint256(toWihtExtra));

        toWihtExtra = bytes32(toWihtExtra >> _BITPOS_PRESALE_ADDRESS);
        address to = address(uint160(uint256(toWihtExtra)));
        bool freeMinting = uint8(uint256(toWihtExtra) >> _BITPOS_PRESALE_FREE_MINTING) != 0;
        bool soulbound = uint8(uint256(toWihtExtra) >> _BITPOS_PRESALE_SOULBOUND) != 0;
        uint16 maxAmount = (uint16(uint256(toWihtExtra) >> _BITPOS_PRESALE_MAX_AMOUNT));

        if (amount == 0) _revert(InvalidAmount.selector);

        _usedAmountSignature[signature] += amount;
        if (_usedAmountSignature[signature] > maxAmount) revert NotEnoughAmountToMint();

        if (_actualSoldTokens() + amount > _availableCollectionSize) revert CollectionSoldOut();

        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();

        address signer = ECDSA.recoverCalldata(
            ECDSA.toEthSignedMessageHash(
                keccak256(
                    abi.encodePacked(
                        this.mintWhitelist.selector,                             
                        address(this),                                         
                        block.chainid,                                         
                        toWihtExtra,
                        customFee
                    )
                )
            ),
            signature
        );

        if (signer != N2M_SIGNER && signer != owner()) _revert(SignatureMismatch.selector);

        if (freeMinting) {

            customFee = 0;
        } else if (customFee == 0) {
            customFee = _creatorMintFee(amount);
        } else {
            customFee *= amount;
        }
        _requireFeesPayment(customFee, _protocolFee()*amount);
        _mintSequential(to, amount, soulbound);
    }

    function mintAllowlist(uint256 amount, bytes32[] calldata _proof) external payable override {

        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();
        if (!allowListed(msg.sender, _proof)) revert NotAllowlisted();
        _requireFee(amount);

        _currentIndex += uint32(amount);
        if (_actualSoldTokens() > _availableCollectionSize) revert CollectionSoldOut();

        __mint(msg.sender, amount);
    }

    function reduceCollectionSize(uint32 newCollectionSize) external payable override onlyOwner {
        _reduceCollectionSize(newCollectionSize);
    }

    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.
    function isMetadataFixed() public view override(Common, IN2MCommon) returns (bool) {
        return (_isMetadataEditable == false);
    }

    function mintingType() external pure override(Common, IN2MCommon) returns (MintingType) {
        return MintingType.SEQUENTIAL;
    }

    function _actualSoldTokens() internal view virtual override returns (uint32) {
        return _currentIndex - 1;
    }

    function _nextTokenId() internal view virtual override returns (uint32) {
        return _currentIndex;
    }    

    function __mint(address to, uint256 amount) internal virtual;

}
