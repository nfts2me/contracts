/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                Smart contract generated by https://nfts2me.com                //
 *                                                                               //
 *                                      .::.                                     //
 *                                    ......                                     //
 *                                ....        ::.                                //
 *                             .:..           :: ...                             //
 *                         ..:.               ::     ...                         //
 *                       ::.      ..:--       ::.       ...                      //
 *                      .:    ..:::::-==:     :::::..     :                      //
 *                      .:    :::::::-====:   ::::::::    :                      //
 *                      .:    :::::::-======. ::::::::    :                      //
 *                      .:    :::::::-=======-::::::::    :                      //
 *                      .:    :::::::-========-:::::::    :                      //
 *                      .:    ::::::::========-:::::::    :                      //
 *                      .:    :::::::. .======-:::::::    :                      //
 *                      .:    :::::::.   :====-:::::::    :                      //
 *                      .:     .:::::.     -==-:::::.     :                      //
 *                       .:.       .:.      .--:..      ...                      //
 *                          .:.     :.               ...                         //
 *                             .... :.           ....                            //
 *                                 .:.        .:.                                //
 *                                      .::::.                                   //
 *                                      :--.                                     //
 *                                                                               //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 *   More info at: https://docs.nfts2me.com/                                     //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {ERC721A, IERC7496, IERC5192, Common, DynamicNFT} from "./ERC721A/ERC721A.sol";
import {IERC165, IERC2981} from "openzeppelin/contracts/interfaces/IERC2981.sol";
import {Address} from "openzeppelin/contracts/utils/Address.sol";
import {LibString} from "solady/utils/LibString.sol";
import {Base64} from "solady/utils/Base64.sol";

/// @title NFTs2Me.com Smart Contracts for ERC-721.
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact security@nfts2me.com
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
contract N2MERC721A is ERC721A {
    constructor(address payable factoryAddress, uint256 protocolFee_) Common(factoryAddress, protocolFee_) ERC721A() payable {}

    function _requireTokenOwned(uint256 tokenId) internal view virtual override {
        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();
    }

    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view override(ERC721A) {
       return ERC721A._checkAuthorized(owner, spender, tokenId);
    }

    function totalSupply() public view override(ERC721A) returns (uint256) {
        return ERC721A.totalSupply();
    }

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721A)
        returns (string memory)
    {
        _requireTokenOwned(tokenId);

        if (_isDynamicNFT) {
            return DynamicNFT(address(this)).dynamicTokenURI(tokenId);
        }

        string memory stringTokenId = LibString.toString(tokenId);
        string memory baseURI;
        if (_baseURICIDHash != 0) {
            baseURI = _getIPFSURI(_baseURICIDHash);
        } else {
            baseURI = _baseURIString;
        }

        string memory nameString;
        string memory descriptionString;
        {
            bool isInline;
            if (_hasPlaceholder) {
                isInline = true;
                nameString = 'Unrevealed Token';
            } else if (_isEditions) {
                isInline = true;
                nameString = LibString.escapeJSON(_name);
                if (bytes(_collectionDescription).length != 0) {
                    descriptionString = string(abi.encodePacked('","description":"', LibString.escapeJSON(_collectionDescription)));
                }

                if (_baseURICIDHash != 0 && bytes(_baseURIString).length != 0) {

                    descriptionString = string(abi.encodePacked(descriptionString, '","animation_url":"', _baseURIString));
                }
            }

            if (isInline) {
                return string(
                    abi.encodePacked(
                        'data:application/json;base64,',
                        Base64.encode(
                            abi.encodePacked(
                                '{"name":"',
                                nameString,
                                ' #' ,
                                stringTokenId,
                                descriptionString,
                                '","image":"',
                                baseURI,
                                '"}'
                            )
                        )
                    )
                );

            } 
        }

        return
            string(
                abi.encodePacked(
                    baseURI,
                    "/",
                    stringTokenId,
                    ".json"
                )
            );
    }

    function __mint(address to, uint256 amount)
        internal
        override
    {
        _mint(to, uint32(amount));
    }

    /**
     * @dev See {IERC721Metadata-name}.
     */
    function name()
        public
        view
        override(ERC721A)
        returns (string memory)
    {
        return _name;
    }

    /**
     * @dev Hook that is called before a set of serially-ordered token IDs
     * are about to be transferred. This includes minting.
     * And also called before burning one token.
     *
     * `startTokenId` - the first token ID to be transferred.
     * `quantity` - the amount to be transferred.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, `tokenId` will be burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfers(
        address from,
        address,
        uint256 startTokenId,
        uint256 quantity
    ) internal override virtual {
        /// Only check the first and last token. On edge scenarios this may not be enough.
        if (
            from != address(0) &&
            (_soulbound[startTokenId] || _soulbound[startTokenId + quantity - 1] || _soulboundCollection)
        ) _revert(NonTransferrableSoulboundNFT.selector);
    }

    /**
     * @dev Hook that is called after a set of serially-ordered token IDs
     * have been transferred. This includes minting.
     * And also called after one token has been burned.
     *
     * `startTokenId` - the first token ID to be transferred.
     * `quantity` - the amount to be transferred.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
     * transferred to `to`.
     * - When `from` is zero, `tokenId` has been minted for `to`.
     * - When `to` is zero, `tokenId` has been burned by `from`.
     * - `from` and `to` are never both zero.
     */
    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal override virtual {
        if (to != address(0)) {

            if (_maxPerAddress != 0) {
                if (_balanceOfData[to] > _maxPerAddress) _revert(MaxPerAddressExceeded.selector);
            }
        }

        if (_isDynamicNFT) {
            Address.functionDelegateCall(address(_dynamicNFT), abi.encodeWithSelector(DynamicNFT.tokenBulkUpdate.selector, from, to, startTokenId, quantity));
        }      
    }

    /// @notice Query if a contract implements an interface
    /// @param interfaceId The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceId` and `interfaceId` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceId)
        public
        pure
        override(ERC721A)
        returns (bool)
    {
        if (interfaceId == IERC165_INTERFACE_ID) return true;         
        if (interfaceId == IERC173_INTERFACE_ID) return true;         
        if (interfaceId == IERC721_INTERFACE_ID) return true;         
        if (interfaceId == IERC721METADATA_INTERFACE_ID) return true; 
        if (interfaceId == IERC2981_INTERFACE_ID) return true;        
        if (interfaceId == IERC4907_INTERFACE_ID) return true;        
        if (interfaceId == IERC7496_INTERFACE_ID) return true;        
        return (interfaceId == IERC5192_INTERFACE_ID);                
    }

    /**
     * @dev See {IERC721Metadata-symbol}.
     */
    function symbol()
        public
        view
        virtual
        override(ERC721A)
        returns (string memory)
    {
        return _symbol;
    }

    /// @notice Enable or disable approval for a third party ("operator") to manage
    ///  all of `msg.sender`'s assets
    /// @dev Emits the ApprovalForAll event. The contract MUST allow
    ///  multiple operators per owner.
    /// @param operator Address to add to the set of authorized operators
    /// @param approved True if the operator is approved, false to revoke approval
    function setApprovalForAll(address operator, bool approved) public override(ERC721A) onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    /// @notice Change or reaffirm the approved address for an NFT
    /// @dev The zero address indicates there is no approved address.
    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized
    ///  operator of the current owner.
    /// @param operator The new approved NFT controller
    /// @param tokenId The NFT to approve
    function approve(address operator, uint256 tokenId) public override(ERC721A) payable onlyAllowedOperatorApproval(operator) {
        super.approve(operator, tokenId);
    }

    /// @notice Query if an address is an authorized operator for another address
    /// @param owner_ The address that owns the NFTs
    /// @param operator The address that acts on behalf of the owner
    /// @return True if `operator` is an approved operator for `owner`, false otherwise
    function isApprovedForAll(address owner_, address operator)
    public
    view
    virtual
    override(ERC721A)
    returns (bool)
    {

        if (operator == OPENSEA_CONDUIT && _operatorFilterStatus == OperatorFilterStatus.DISABLED) return true;
        if (operator == N2M_CONDUIT) return true;

        return super.isApprovedForAll(owner_, operator);
    }

    function burn(uint256 tokenId) external payable {
        _burn(tokenId, true);
    }
}
