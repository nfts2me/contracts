/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                Smart contract generated by https://nfts2me.com                //
 *                                                                               //
 *                                      .::.                                     //
 *                                    ......                                     //
 *                                ....        ::.                                //
 *                             .:..           :: ...                             //
 *                         ..:.               ::     ...                         //
 *                       ::.      ..:--       ::.       ...                      //
 *                      .:    ..:::::-==:     :::::..     :                      //
 *                      .:    :::::::-====:   ::::::::    :                      //
 *                      .:    :::::::-======. ::::::::    :                      //
 *                      .:    :::::::-=======-::::::::    :                      //
 *                      .:    :::::::-========-:::::::    :                      //
 *                      .:    ::::::::========-:::::::    :                      //
 *                      .:    :::::::. .======-:::::::    :                      //
 *                      .:    :::::::.   :====-:::::::    :                      //
 *                      .:     .:::::.     -==-:::::.     :                      //
 *                       .:.       .:.      .--:..      ...                      //
 *                          .:.     :.               ...                         //
 *                             .... :.           ....                            //
 *                                 .:.        .:.                                //
 *                                      .::::.                                   //
 *                                      :--.                                     //
 *                                                                               //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 *   More info at: https://docs.nfts2me.com/                                     //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {IERC7496, IERC5192, ECDSA, Common, N2MCommonStorage, IN2MCommon, DynamicNFT, DynamicPrice, IBlast} from "../Common.sol";
import {IN2MCrossFactory} from "../interfaces/IN2MCrossFactory.sol";
import {IN2MNonSequential} from "../interfaces/IN2MNonSequential.sol";

/// @title NFTs2Me.com Smart Contracts
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact security@nfts2me.com
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
abstract contract NSMinting is Common, IN2MNonSequential {
    function initialize008joDSK(
        string calldata name_,
        string calldata symbol_,
        uint256 mintPrice_,
        bytes32 baseURICIDHash,
        bytes32 packedData,
        bytes calldata extraCollectionInformation
    ) public payable override initializer {
		IBlast(BLAST_TESTNET).configureAutomaticYield();
		IBlast(BLAST_TESTNET).configureClaimableGas();
        _name = name_;
        _symbol = symbol_;

        if (mintPrice_ > 0) _mintPrice = mintPrice_;

        _availableCollectionSize = uint32(uint256(packedData) >> _BITPOS_INIT_COLLECTION_SIZE);

        _royaltyFee = uint16(uint256(packedData) >> _BITPOS_INIT_ROYALTY_FEE);

        _mintingType = MintingType(uint8(uint256(packedData) >> _BITPOS_INIT_MINTING_TYPE));

        if (baseURICIDHash != bytes32(0)) _baseURICIDHash = baseURICIDHash;
        uint256 extraCollectionInformationLength = extraCollectionInformation.length;
        if (extraCollectionInformationLength > 0) {

            uint8 bitmap = uint8(uint256(packedData) >> _BITPOS_INIT_BITMAP);

            bool isSoulbound = (bitmap & BIT1MASK) != 0;
            bool hasPlaceholder = (bitmap & BIT2MASK) != 0;
            bool hasDynamicPrice = (bitmap & BIT3MASK) != 0;
            bool hasEditableMetadata = bitmap & BIT4MASK != 0;
            uint16 reservedTokens_ = uint16(uint256(packedData) >> _BITPOS_INIT_RESERVED_TOKENS);

            if (isSoulbound) {
                _soulboundCollection = true;
            }

            if (hasPlaceholder) {
                _hasPlaceholder = true;
                _isMetadataEditable = true;
            }

            if (hasEditableMetadata) {
                _isMetadataEditable = true;
            }

            if (hasDynamicPrice) {
                _hasDynamicPrice = true;
            }

            if (reservedTokens_ > 0) {

                _reservedTokens = reservedTokens_;
                if (_actualCollectionSize() > type(uint32).max) _revert(InvadlidCollectionSize.selector);
            }

            if (extraCollectionInformationLength > 1) {

                bool hasStrings = bitmap & BIT5MASK != 0;
                bool hasDynamicNFTAddress = bitmap & BIT6MASK != 0;
                bool hasERC20PaymentAddress = bitmap & BIT7MASK != 0;
                bytes32[] memory bArray;

                if (hasStrings) {

                    string memory baseURIString_;
                    string memory collectionDescription_;
                    (bArray, baseURIString_, collectionDescription_) = abi.decode(extraCollectionInformation, (bytes32[], string, string));
                    if (bytes(baseURIString_).length > 0) _baseURIString = baseURIString_;
                    if (bytes(collectionDescription_).length > 0) _collectionDescription = collectionDescription_;
                } else {
                    (bArray) = abi.decode(extraCollectionInformation, (bytes32[]));
                }

                uint256 index;
                SalePhase initPhase = SalePhase(uint8(uint256(packedData >> _BITPOS_INIT_PHASE)));
                if (initPhase > SalePhase.PUBLIC) {
                    _currentPhase = initPhase;

                    if (initPhase > SalePhase.PRESALE) {
                        _dropDateTimestamp = uint256(bArray[index++]);
                        _endDateTimestamp = uint256(bArray[index++]);
                    }
                }

                if (hasDynamicNFTAddress) {
                    _isDynamicNFT = true;
                    _dynamicNFT = DynamicNFT(address(uint160(uint256(bArray[index++]))));
                }

                if (hasERC20PaymentAddress) {
                    _isERC20Payment = true;
                    _erc20PaymentAddress = address(uint160(uint256(bArray[index++])));
                }

                uint256 revenuePercentageTotal;
                for (uint256 bArrayLength = bArray.length; index < bArrayLength; index++) {
                    uint256 revenueInfo = uint256(bArray[index]);
                    uint16 percentage = uint16(revenueInfo >> 160);
                    revenuePercentageTotal += percentage;
                    _revenueInfo.push(RevenueAddress(address(uint160(revenueInfo)), percentage));
                }
                if (revenuePercentageTotal > 100_00) revert InvalidRevenuePercentage();
            }
        }

        emit OwnershipTransferred(address(0), address(uint160(uint256(packedData))));
    }

    /// @notice One tx random minting. Mints `amount` NFTs tickets to `to` address. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint 
    function mintRandomTo(address to, uint256 amount) external payable override {
        _requireFee(amount);
        _mintOneStepRandomWithChecks(to, amount);
    }

    /// @notice One tx random minting. Mints `amount` NFTs tickets to `to` address with a given `affiliate`. Requires `minting type` to be `random` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @dev Not real random to be able to mint in one tx.
    /// @param to The address of the NFTs receiver
    /// @param amount The number of NFTs to mint    
    /// @param affiliate The affiliate address
    function mintRandomTo(address to, uint256 amount, address affiliate) external payable override {
        _requirePaymentWithAffiliates(amount, affiliate);
        _mintOneStepRandomWithChecks(to, amount);
    }

    function _mintOneStepRandomWithChecks(address to, uint256 amount) private {
        _checkPhase();
        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();
        if (uint256(_currentIndex) + amount > uint256(_availableCollectionSize)) revert CollectionSoldOut();

        unchecked {
            _currentIndex += uint32(amount);
        }

        /// Note: not real random to be able to mint in one tx.
        _mintRandom(to, amount, block.prevrandao, false);
    }

    function _mintRandom(address to, uint256 amount, uint256 seed, bool soulbound) private {
        while (amount > 0) {
            uint256 tokenId = _randomTokenId(seed, amount);
            __mint(to, tokenId);
            if (soulbound) _setSoulbound(tokenId);
            unchecked {
                --amount;
            }
        }
    }

    function _randomTokenId(uint256 seed, uint256 extraModifier) private view returns (uint256 tokenId) {

        tokenId = (uint256(keccak256(abi.encodePacked(seed, extraModifier))) % _availableCollectionSize) + 1;

        while (_ownerOf(tokenId) != address(0)) {
            tokenId = (tokenId % _availableCollectionSize) + 1;
        }
    }

    /// @notice Mints `amount` NFTs to `to` address. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    function mintSpecifyTo(address to, uint256[] calldata tokenIds)
        external
        payable
        override
    {
        _requireFee(tokenIds.length);
        _mintSpecifyWithChecks(to, tokenIds);
    }

    /// @notice Mints `amount` NFTs to `to` address with a given `affiliate`. Requires `minting type` to be `specify` and the `mintPrice` to be send (if `Native payment`) or approved (if `ERC-20` payment).
    /// @param to The address of the NFTs receiver
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    /// @param affiliate The affiliate address
    function mintSpecifyTo(address to, uint256[] calldata tokenIds, address affiliate) 
        external
        payable
        override
    {
        _requirePaymentWithAffiliates(tokenIds.length, affiliate);
        _mintSpecifyWithChecks(to, tokenIds);
    }

    function _mintSpecifyWithChecks(address to, uint256[] calldata tokenIds)
        private
    {
        _checkPhase();
        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();

        if (_currentIndex + (tokenIds.length) > _availableCollectionSize) revert CollectionSoldOut();

        _mintSpecify(to, tokenIds);
    }

    function _mintSpecify(address to, uint256[] calldata tokenIds, bool soulbound) private {
        _mintSpecify(to, tokenIds);
        if (soulbound) {
            for (uint256 i; i < tokenIds.length; i++) {
                _setSoulbound(tokenIds[i]);
            }
        }
    }

    function _mintSpecify(address to, uint256[] calldata tokenIds) internal virtual
    {

        uint256 inputLength = tokenIds.length;
        _currentIndex += uint32(inputLength);
        for (uint256 i; i < inputLength; i++) {
            uint256 tokenId = tokenIds[i];

            if (tokenId == 0 || tokenId > _availableCollectionSize) revert InvalidTokenId();
            __mint(to, tokenId);
        }
    }

    /// @notice Mints one NFT to `to` address. Requires `minting type` to be `customURI`.
    /// @param to The address of the NFTs receiver
    /// @param customURICIDHash The CID of the given token.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function mintCustomURITo(address to, bytes32 customURICIDHash, bool soulbound)
        external
        payable
        override
    {
        _requireFeesPayment(_creatorMintFee(), _protocolFee());
        _checkPhase();
        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();
        _mintCustomURIInternal(to, customURICIDHash, soulbound);
    }

    function _mintCustomURIInternal(address to, bytes32 customURICIDHash, bool soulbound) private {
        unchecked {
            if ((++_currentIndex) > _availableCollectionSize) revert CollectionSoldOut();
        }
        __mint(to, _currentIndex);

        if (soulbound) _setSoulbound(_currentIndex);
        _customURICIDHashes[_currentIndex] = customURICIDHash;
    }

    /// @notice Airdrop mints one NFT to `to` addresses. Requires `minting type` to be `customURI`.
    /// @param to The address of the NFTs receiver
    /// @param customURICIDHash The CIDs of the given token.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropCustomURI(address[] calldata to, bytes32[] calldata customURICIDHash, bool soulbound)
        external
        payable
        onlyOwner
        override
    {
        if (to.length != customURICIDHash.length) revert InvalidInputSizesDontMatch();
        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();
        for (uint256 i; i < to.length; i++) {
            _mintCustomURIInternal(to[i], customURICIDHash[i], soulbound);
        }
    }

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with random tokenIds. Requires `minting type` to be `random`.
    /// @param to The addresses of the NFTs receivers
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropRandom(address[] calldata to, bool soulbound)
        external
        payable
        override
        onlyOwner
    {
        uint256 toLength = to.length;
        if (_mintingType != MintingType.RANDOM) revert InvalidMintingType();

        if ((_currentIndex + toLength) > _availableCollectionSize) revert CollectionSoldOut();

        unchecked {
            _currentIndex += uint32(toLength);
        }

        for (uint256 i; i < toLength; i++) {
            uint256 newTokenId = _randomTokenId(block.prevrandao, i);
            __mint(to[i], newTokenId);
            if (soulbound) _setSoulbound(newTokenId);
        }
    }

    /// @notice Only owner can call this function. Free of charge. Mints sizeof(`to`) to `to` addresses with specified tokenIds. Requires `minting type` to be `specify`.
    /// @param to The addresses of the NFTs receivers
    /// @param tokenIds An array of the specified tokens. They must not be minted, otherwise, it will revert.
    /// @param soulbound True if the NFT is a Soulbound Token (SBT). If set, it can't be transferred.
    function airdropSpecify(
        address[] calldata to,
        uint256[] calldata tokenIds,
        bool soulbound
    ) external payable override onlyOwner {
        uint256 toLength = to.length;
        if (_mintingType != MintingType.SPECIFY) revert InvalidMintingType();

        if (_currentIndex + (tokenIds.length) > _availableCollectionSize) revert CollectionSoldOut();
        if (toLength != tokenIds.length) revert InvalidInputSizesDontMatch();

        unchecked {
            _currentIndex += uint32(toLength);
        }

        for (uint256 i; i < toLength; i++) {

            if (tokenIds[i] == 0 || tokenIds[i] > _availableCollectionSize) revert InvalidTokenId();
            __mint(to[i], tokenIds[i]);
            if (soulbound) _setSoulbound(tokenIds[i]);
        }
    }

    /// @notice Mints `amount` of NFTs to `to` address with optional specified tokenIds. This function must be called only if a valid `signature` is given during a whitelisting/presale.
    /// @param toWihtExtra To address packed with extra information.
    /// @param customFee Zero is fee is different from `mintingPrice`.
    /// @param signature Valid `signature` for the presale/whitelist.
    function mintWhitelist(
        bytes32 toWihtExtra,
        uint256 customFee,
        bytes calldata signature,
        uint256[] calldata tokenIds
    ) external payable override {

        uint16 amount = uint16(uint256(toWihtExtra));

        toWihtExtra = bytes32(toWihtExtra >> _BITPOS_PRESALE_ADDRESS);
        address to = address(uint160(uint256(toWihtExtra)));
        bool freeMinting = uint8(uint256(toWihtExtra) >> _BITPOS_PRESALE_FREE_MINTING) != 0;
        bool soulbound = uint8(uint256(toWihtExtra) >> _BITPOS_PRESALE_SOULBOUND) != 0;
        uint16 maxAmount = (uint16(uint256(toWihtExtra) >> _BITPOS_PRESALE_MAX_AMOUNT));

        if (amount == 0) _revert(InvalidAmount.selector);

        _usedAmountSignature[signature] += amount;
        if (_usedAmountSignature[signature] > maxAmount) revert NotEnoughAmountToMint();

        if (_currentIndex + amount > _availableCollectionSize) revert CollectionSoldOut();

        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();

        address signer = ECDSA.recoverCalldata(
            ECDSA.toEthSignedMessageHash(
                keccak256(
                    abi.encodePacked(
                        this.mintWhitelist.selector,                           
                        address(this),                                         
                        block.chainid,                                         
                        toWihtExtra,
                        customFee
                    )
                )
            ),
            signature
        );

        if (signer != N2M_SIGNER && signer != owner()) _revert(SignatureMismatch.selector);

        if (freeMinting) {

            customFee = 0;
        } else if (customFee == 0) {
            customFee = _creatorMintFee(amount);
        } else {
            customFee *= amount;
        }
        _requireFeesPayment(customFee, _protocolFee()*amount);

        if (_mintingType == MintingType.RANDOM) {
            _currentIndex += uint32(amount);
            _mintRandom(to, amount, uint256(keccak256(signature)), soulbound);
        } else {

            if (tokenIds.length != amount) revert InvalidInputSizesDontMatch();
            if (_mintingType == MintingType.CUSTOM_URI) {
                for (uint256 i; i<amount; i++) {
                    _mintCustomURIInternal(to, bytes32(tokenIds[i]), soulbound);
                }
            } else if (_mintingType == MintingType.SPECIFY) {
                _mintSpecify(to, tokenIds, soulbound);
            } else {

                revert PresaleInvalidMintingType();
            }
        }
    }

    function mintAllowlist(uint256 amount, bytes32[] calldata proof) external payable override {

        if (_currentPhase == SalePhase.CLOSED) revert PresaleNotOpen();
        if (_mintingType != MintingType.RANDOM) revert PresaleInvalidMintingType();
        if (!allowListed(msg.sender, proof)) revert NotAllowlisted();
        _requireFee(amount);

        _currentIndex += uint32(amount);
        if (_actualSoldTokens() > _availableCollectionSize) revert CollectionSoldOut();

        _mintRandom(msg.sender, amount, uint256(proof[0]), false);
    }

    function reduceCollectionSize(uint32 newCollectionSize) external payable override onlyOwner {
        if (_mintingType != MintingType.CUSTOM_URI) revert InvalidMintingType();
        _reduceCollectionSize(newCollectionSize);
    }

    /// @notice Returns true if the metadata is fixed and immutable. If the metadata hasn't been fixed yet it will return false. Once fixed, it can't be changed by anyone.
    function isMetadataFixed() public view override(Common, IN2MCommon) returns (bool) {
        return (_isMetadataEditable == false || _mintingType == MintingType.CUSTOM_URI);
    }

    function mintingType() external view override(Common, IN2MCommon) returns (MintingType) {
        return _mintingType;
    }

    function _actualSoldTokens() internal view override returns (uint32) {
        return _currentIndex;
    }

    function _nextTokenId() internal view override returns (uint32) {
        return _actualSoldTokens() + 1;
    }

    function __mint(address to, uint256 tokenId) internal virtual;

}
