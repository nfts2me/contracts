/** ---------------------------------------------------------------------------- //
 *                                                                               //
 *                Smart contract generated by https://nfts2me.com                //
 *                                                                               //
 *                                      .::.                                     //
 *                                    ......                                     //
 *                                ....        ::.                                //
 *                             .:..           :: ...                             //
 *                         ..:.               ::     ...                         //
 *                       ::.      ..:--       ::.       ...                      //
 *                      .:    ..:::::-==:     :::::..     :                      //
 *                      .:    :::::::-====:   ::::::::    :                      //
 *                      .:    :::::::-======. ::::::::    :                      //
 *                      .:    :::::::-=======-::::::::    :                      //
 *                      .:    :::::::-========-:::::::    :                      //
 *                      .:    ::::::::========-:::::::    :                      //
 *                      .:    :::::::. .======-:::::::    :                      //
 *                      .:    :::::::.   :====-:::::::    :                      //
 *                      .:     .:::::.     -==-:::::.     :                      //
 *                       .:.       .:.      .--:..      ...                      //
 *                          .:.     :.               ...                         //
 *                             .... :.           ....                            //
 *                                 .:.        .:.                                //
 *                                      .::::.                                   //
 *                                      :--.                                     //
 *                                                                               //
 *                                                                               //
 *   NFTs2Me. Make an NFT Collection.                                            //
 *   With ZERO Coding Skills.                                                    //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 *   NFTs2Me Terms of Service: https://nfts2me.com/terms-of-service/             //
 *   More info at: https://docs.nfts2me.com/                                     //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.25;

import {IERC20} from "openzeppelin/contracts/token/ERC20/IERC20.sol";

import {IN2MCrossFactory} from "./interfaces/IN2MCrossFactory.sol";
import {N2MCommonStorage, IN2MCommonStorage, DynamicNFT} from "./Storage.sol";
import {DynamicPrice} from "./interfaces/DynamicPrice.sol";
import {IN2MCommon, IERC4907, IERC5192, IERC7496} from "./interfaces/IN2MCommon.sol";

/// Utils
import {LibString} from "solady/utils/LibString.sol";
import {ECDSA} from "solady/utils/ECDSA.sol";
import {MerkleProofLib} from "solady/utils/MerkleProofLib.sol";
import {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";

/// @title NFTs2Me.com Smart Contracts
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact security@nfts2me.com
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
abstract contract Common is IN2MCommon, N2MCommonStorage {
    constructor(address payable factoryAddress_, uint256 protocolFee_) N2MCommonStorage(factoryAddress_, protocolFee_) {
        /// Disable initilization
        _currentPhase = SalePhase.CLOSED;
    }

    modifier initializer() {
        uint256 packedData;
        assembly {
            packedData := sload(_availableCollectionSize.slot)
        }        
        if (packedData > 0) {
            _revert(InvalidInitialization.selector);
        }
        _;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    function _checkOwner() internal view virtual {
        if (msg.sender != FACTORY) {
            if (owner() != msg.sender) {
                revert OwnableUnauthorizedAccount(msg.sender);
            }
        }
    }

    /// @notice Returns the address of the current collection owner.
    function owner() public view override returns (address collectionOwner) {
        return IN2MCrossFactory(FACTORY).ownerOf(uint256(uint160(address(this))));
    }

    function transferOwnership(address to) external payable override onlyOwner {
        IN2MCrossFactory(FACTORY).transferCollectionOwnership(to);
    }

    function ownershipTransferred(address from, address to) external payable {
        if (msg.sender != FACTORY) revert();
        emit OwnershipTransferred(from, to);
    }

    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        /// On the first call to nonReentrant, _status will be 0 or NOT_ENTERED
        if (_reentrancyStatus == REENTRANCY_ENTERED) {
            _revert(ReentrancyGuard.selector);
        }

        /// Any calls to nonReentrant after this point will fail
        _reentrancyStatus = REENTRANCY_ENTERED;
    }

    function _nonReentrantAfter() private {
        /// By storing the original value once again, a refund is triggered (see
        /// https://eips.ethereum.org/EIPS/eip-2200)
        _reentrancyStatus = REENTRANCY_NOT_ENTERED;
    }

    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual;

    function _ownerOf(uint256 tokenId) internal view virtual returns (address);

    function _requireTokenOwned(uint256 tokenId) internal view virtual;

    function _setSoulbound(uint256 tokenId) internal {
        _soulbound[tokenId] = true;
        emit Locked(tokenId);
    }

    function locked(uint256 tokenId) external view override returns (bool) {
        _requireTokenOwned(tokenId);
        return (_soulbound[tokenId] || _soulboundCollection);
    }

    /// @notice Returns the current total supply.
    /// @return Current total supply.
    function totalSupply() public virtual view returns (uint256) {
        return _actualSoldTokens() - uint256(_burnedTokens);
    }

    function collectionSize() external view override returns (uint256 size) {
        size = _actualCollectionSize();
        if (size == type(uint32).max) {
            return 0;
        } else {
            return size - _burnedTokens;
        }
    }

    function _actualCollectionSize() internal view returns (uint256) {
        return uint256(_availableCollectionSize) + uint256(_reservedTokens);
    }

    /// @notice Max amount of NFTs to be hold per address.
    /// @return Max per address allowed.
    function maxPerAddress() external view override returns (uint256) {
        return _maxPerAddress;
    }

    /**
     * @dev For more efficient reverts.
     */
    function _revert(bytes4 errorSelector) internal pure {
        assembly {
            mstore(0x00, errorSelector)
            revert(0x00, 0x04)
        }
    }

    function _getIPFSURI(bytes32 CIDHash) internal view returns (string memory) {
        return IN2MCrossFactory(FACTORY).getIPFSURI(CIDHash);
    }

    function mintingType() external virtual view returns (MintingType) {
        return _mintingType;        
    }

    function _reduceCollectionSize(uint32 newAvailableCollectionSize) internal {
        if (newAvailableCollectionSize == 0 || newAvailableCollectionSize >= _availableCollectionSize || newAvailableCollectionSize < _actualSoldTokens()) _revert(InvadlidCollectionSize.selector);
        _availableCollectionSize = newAvailableCollectionSize;
    }

    function reserveTokens(uint16 amount) external payable override onlyOwner {
        if ((uint256(amount) + _actualSoldTokens()) > uint256(_availableCollectionSize)) _revert(InvalidAmount.selector);
        if ((uint256(amount) + _reservedTokens) > type(uint16).max) _revert(InvalidAmount.selector);
        _reservedTokens += amount;
        _availableCollectionSize -= amount;
    }

    function unreserveTokens(uint16 amount) external payable override onlyOwner {
        if (amount > _reservedTokens) _revert(InvalidAmount.selector);
        _reservedTokens -= amount;
        _availableCollectionSize += amount;
    }

    function reservedTokens() external view override returns (uint256) {
        return _reservedTokens;
    }

    function _actualSoldTokens() internal view virtual returns (uint32);

    function _nextTokenId() internal view virtual returns (uint32);

    function merkleRoot() external view override returns (bytes32) {
        return _merkleRoot;
    }

    function setMerkleRoot(bytes32 merkleRoot_) external payable override onlyOwner {
        _merkleRoot = merkleRoot_;
    }

    function allowListed(address _wallet, bytes32[] calldata _proof)
      public
      view
      override
      returns (bool)
    {
      return
          MerkleProofLib.verify(
              _proof,
              _merkleRoot,
              keccak256(abi.encodePacked(_wallet))
          );
    }

    function mintFee(uint256 amount) external view override returns (uint256) {
        return _creatorMintFee(amount);
    }

    function protocolFee() public view override returns (uint256) {
        if (_feesRemoved) return 0;
        return PROTOCOL_FEE;
    }

    function _protocolFee() internal view returns (uint256) {
        return PROTOCOL_FEE;
    }

    function _creatorMintFee() internal view returns (uint256) {
        if (!_hasDynamicPrice) {
            return _mintPrice;
        }
        return DynamicPrice(address(this)).mintPrice(msg.sender, 1);

    }

    function _creatorMintFee(uint256 amount) internal view returns (uint256) {
        if (!_hasDynamicPrice) {
            return _mintPrice * amount;
        }
        return DynamicPrice(address(this)).mintPrice(msg.sender, amount);

    }

    function changeMintFee(uint256 newMintPrice, bool isDynamic) external payable override onlyOwner {
        _mintPrice = newMintPrice;
        if (isDynamic != _hasDynamicPrice) _hasDynamicPrice = isDynamic;
    }

    function _requirePaymentWithAffiliates(uint256 amount, address affiliate)
        internal
    {
        uint256 currentUserDiscount;
        uint256 currentAffiliatePercentage;
        if (_affiliatesInfo[affiliate].enabled) {
            currentUserDiscount = _affiliatesInfo[affiliate].userDiscount;
            currentAffiliatePercentage = _affiliatesInfo[affiliate].affiliatePercentage;
        } else {
            currentUserDiscount = _affiliatesInfo[address(0)].userDiscount;
            currentAffiliatePercentage = _affiliatesInfo[address(0)].affiliatePercentage;
        }

        uint256 discountMintPrice = ((100_00 - currentUserDiscount) * _creatorMintFee(amount)) / 100_00;
        _requireFeesPayment(discountMintPrice, _protocolFee()*amount);
        if (affiliate != address(0)) {
            uint256 affiliateAmount = (currentAffiliatePercentage * discountMintPrice * amount) / 100_00;
            _pendingTotalAffiliatesBalance += affiliateAmount;
            pendingAffiliateBalance[affiliate] += affiliateAmount;
            emit AffiliateSell(affiliate);
        }
    }

    function removeProtocolFee(bytes calldata signature, uint256 fee, address feeReceiver) external payable override {
        address signer = ECDSA.recoverCalldata(
            ECDSA.toEthSignedMessageHash(
                keccak256(
                    abi.encodePacked(
                        this.removeProtocolFee.selector,                       
                        fee,                                                 
                        feeReceiver,                                         
                        address(this),                                         
                        block.chainid                                          
                    )
                )
            ),
            signature
        );

        if (signer != N2M_SIGNER) _revert(SignatureMismatch.selector);
        _feesRemoved = true;

        if (fee > 0) {
            if (msg.value < fee) _revert(InvalidAmount.selector);

            bool success;
            assembly {
                success := call(gas(), feeReceiver, fee, 0, 0, 0, 0)
            }
            if (success == false) revert();
        }
    }

    function _requireFee(uint256 amount) internal {
        _requireFeesPayment(_creatorMintFee(amount), _protocolFee()*amount);
    }

    function _requireFeesPayment(uint256 creatorMintFee, uint256 n2mFee) internal {
        uint256 pendingMsgValue = msg.value;

        if (creatorMintFee > 0) {
            if (_isERC20Payment == false) {
                if (pendingMsgValue < creatorMintFee) revert InvalidMintFee();
                pendingMsgValue -= creatorMintFee;
            } else {
                SafeTransferLib.safeTransferFrom(
                    _erc20PaymentAddress,
                    msg.sender,
                    address(this),
                    creatorMintFee
                );
            }
        }

        if (_feesRemoved == false) {
            if (pendingMsgValue < n2mFee) revert InvalidMintFee();

            bool success;
            assembly {
                success := call(gas(), PROTOCOL_FEE_RECIPIENT, pendingMsgValue, 0, 0, 0, 0)
            }
            if (success == false) revert InvalidMintFee();
        }
    }

    function changeERC20PaymentAddress(address newErc20PaymentAddress) external payable override onlyOwner {
        if (_pendingTotalAffiliatesBalance > 0) _revert(PendingAffiliatesBalance.selector);
        _erc20PaymentAddress = newErc20PaymentAddress;
        _isERC20Payment = (newErc20PaymentAddress != address(0));
    }

    function _erc20Transfer(address erc20Address, address to, uint256 amount) internal {
        IERC20(erc20Address).transfer(to, amount);
    }

    function withdrawERC20(address erc20Address)
        external
        payable
        override
        nonReentrant
        onlyOwner
    {
        uint256 availableBalance = SafeTransferLib.balanceOf(erc20Address, address(this));
        if (availableBalance == 0) return;
        if (_erc20PaymentAddress == erc20Address) {

            if (_pendingTotalAffiliatesBalance >= availableBalance) return;
            unchecked {
                availableBalance -= _pendingTotalAffiliatesBalance;
            }
        }

        uint256 withdrawn;

        uint256 amountToSend;
        uint256 revenuePercentageTotal;
        uint256 revenueAddressesLength = _revenueInfo.length;
        for (uint256 i; i < revenueAddressesLength; i++) {
            uint256 iPercentage = _revenueInfo[i].percentage;
            revenuePercentageTotal += iPercentage;
            amountToSend = ((availableBalance * iPercentage) / 100_00);
            try IERC20(erc20Address).transfer(_revenueInfo[i].to, amountToSend) {
                withdrawn += amountToSend;
            } catch {

            }
        }

        _erc20Transfer(erc20Address, owner(), (availableBalance - withdrawn));
        withdrawnERC20Amount[erc20Address] += availableBalance;
    }

    function withdraw() external payable override nonReentrant onlyOwner {
        uint256 availableBalance = address(this).balance;
        if (_erc20PaymentAddress == address(0)) {

            if (_pendingTotalAffiliatesBalance >= availableBalance) return;
            unchecked {
                availableBalance -= _pendingTotalAffiliatesBalance;
            }
        }

        uint256 withdrawn;
        bool success;

        uint256 amountToSend;
        uint256 revenuePercentageTotal;
        uint256 revenueAddressesLength = _revenueInfo.length;
        for (uint256 i; i < revenueAddressesLength; i++) {
            uint256 iPercentage = _revenueInfo[i].percentage;
            revenuePercentageTotal += iPercentage;
            amountToSend = ((availableBalance * iPercentage) / 100_00);
            if (_revenueInfo[i].to != address(0)) {
                address revenueReceiver = _revenueInfo[i].to;
                assembly {
                    success := call(gas(), revenueReceiver, amountToSend, 0, 0, 0, 0)
                }
                if (success) {
                    withdrawn += amountToSend;
                }
            }
        }

        address contractOwner = owner();
        amountToSend = (availableBalance - withdrawn);
        assembly {
            success := call(gas(), contractOwner, amountToSend, 0, 0, 0, 0)
        }
        if (success) {
            _withdrawnAmount += availableBalance;
        } else {
            _withdrawnAmount += withdrawn; 
        }
    }

    function affiliateWithdraw(address affiliate) external payable override nonReentrant {

        if (affiliate != msg.sender && PROTOCOL_FEE_RECIPIENT != msg.sender) revert OwnableUnauthorizedAccount(msg.sender);

        uint256 pending = pendingAffiliateBalance[affiliate];

        delete(pendingAffiliateBalance[affiliate]);
        if (pending > _pendingTotalAffiliatesBalance) pending = _pendingTotalAffiliatesBalance;
        unchecked {
            _pendingTotalAffiliatesBalance -= pending;
        }

        /// More gas efficient because _isERC20Payment is not hot and is packed.
        if (_erc20PaymentAddress == address(0)) { 
            assembly {
                pop(call(gas(), affiliate, pending, 0, 0, 0, 0))
            }
        } else {
            _erc20Transfer(_erc20PaymentAddress, affiliate, pending);
        }
    }

    function setAffiliatesPercentageAndDiscount(
        uint16 userDiscount,
        uint16 affiliatePercentage,
        address affiliateAddress
    ) external override onlyOwner {
        AffiliateInformation storage currentAffiliateInfo = _affiliatesInfo[affiliateAddress];
        if ((userDiscount > 100_00) || (affiliatePercentage > 100_00)) {
            _revert(InvalidPercentageOrDiscountValues.selector);
        }
        if ((userDiscount < currentAffiliateInfo.userDiscount) || (affiliatePercentage < currentAffiliateInfo.affiliatePercentage)) {
            _revert(CantLowerCurrentPercentages.selector);
        }
        currentAffiliateInfo.enabled = true;
        currentAffiliateInfo.userDiscount = userDiscount;
        currentAffiliateInfo.affiliatePercentage = affiliatePercentage;
    }

    function affiliatesInfo(address affiliate) external view returns (bool enabled, uint16 affiliatePercentage, uint16 userDiscount) {
        return (_affiliatesInfo[affiliate].enabled, _affiliatesInfo[affiliate].affiliatePercentage, _affiliatesInfo[affiliate].userDiscount);
    }    

    function ownerMaxRevenue() external view returns (uint256 maxRevenue) {
        unchecked {
            for (uint256 i; i<_revenueInfo.length; i++) {
                maxRevenue += _revenueInfo[i].percentage;
            }
            return (100_00 - maxRevenue);
        }
    }    

    function withdrawnAmount() external view returns (uint256) {
        return _withdrawnAmount;
    }

    function pendingTotalAffiliatesBalance() external view returns (uint256) {
        return _pendingTotalAffiliatesBalance;
    }

    function erc20PaymentAddress() external view returns (address) {
        return _erc20PaymentAddress;
    }

    function whitelistOperators(address[] calldata operators) external payable override onlyOwner {
        for (uint256 i = 0; i < operators.length; i++) {
            whitelistedOperators[operators[i]] = true;
        }
        _operatorFilterStatus = OperatorFilterStatus.ENABLED_ONLY_WHITELISTED;
    }

    function disableOperatorFilterRegistry() external payable onlyOwner {
        _operatorFilterStatus = OperatorFilterStatus.DISABLED;
    }

    function isOperatorFilterRegistryEnabled() external view returns (bool) {
        return (_operatorFilterStatus == OperatorFilterStatus.ENABLED_ONLY_WHITELISTED);
    }

    modifier onlyAllowedOperatorApproval(address operator) {
        _isOperatorAllowed(operator);
        _;
    }

    function _isOperatorAllowed(address operator) internal view {
        if (_operatorFilterStatus == OperatorFilterStatus.ENABLED_ONLY_WHITELISTED) {
            if (whitelistedOperators[operator] == false) {
                revert OperatorNotAllowed(operator);
            }
        }

    }

    /// @notice Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of exchange. The royalty amount is denominated and should be paid in that same unit of exchange.
    /// @param salePrice The sale price
    /// @return receiver the receiver of the royalties.
    /// @return royaltyAmount the amount of the royalties for the given input.
    function royaltyInfo(
        uint256, 
        uint256 salePrice
    ) external view virtual returns (address receiver, uint256 royaltyAmount) {

        return (address(this), uint256((salePrice * royaltyFee()) / 100_00));
    }

    function royaltyFee() public view returns (uint256) {
        return _royaltyFee;        
    }

    function changeRoyaltyFee(uint16 newFee) external payable onlyOwner {
        _royaltyFee = newFee;
    }

    function contractURI() public view returns (string memory) {

        if (_contractURIMetadataCIDHash != 0) {
            return _getIPFSURI(_contractURIMetadataCIDHash);
        }

        return
            string(
                abi.encodePacked(
                    "https://metadata.nfts2me.com/api/contractURI/",
                    LibString.toString(block.chainid),
                    "/",
                    LibString.toString(uint256(uint160(address(this)))),
                    "/"
                )
            );
    }

    function setContractURI(bytes32 newContractURIMetadataCIDHash) external payable override onlyOwner {
        _contractURIMetadataCIDHash = newContractURIMetadataCIDHash;
        emit ContractURIUpdated();
    }

    function isMetadataFixed() public view virtual override returns (bool);

    function tokenURI(uint256 tokenId) public view virtual returns (string memory);

    function setBaseURI(string memory baseURIString, bytes32 baseURICIDHash, bool isPlaceholder, bool freezeMetadata) external payable override onlyOwner {
        if (isMetadataFixed()) _revert(MetadataAlreadyFixed.selector);
        if (freezeMetadata) {
            if (isPlaceholder) _revert(PlacerholderCantFreezeMetadata.selector);
            _isMetadataEditable = false;
        }
        if (bytes(baseURIString).length == 0 && baseURICIDHash == 0) _revert(NewBaseURICantBeEmpty.selector);
        _hasPlaceholder = isPlaceholder;
        _baseURICIDHash = baseURICIDHash;
        _baseURIString = baseURIString;

        emit BatchMetadataUpdate(1, type(uint256).max);
    }

    function _checkPhase() internal {
        /// Phases
        if (_currentPhase != SalePhase.PUBLIC) {

            if (_currentPhase == SalePhase.END_DATE) {
                if (block.timestamp > _endDateTimestamp) {
                    revert SaleFinished();
                }
            } else if (_currentPhase == SalePhase.DROP_DATE) {
                if (block.timestamp < _dropDateTimestamp) {
                    revert WaitUntilDropDate();
                }
                _currentPhase = SalePhase.PUBLIC;
                delete(_dropDateTimestamp); /// Safe gas freeing storage
            } else if (_currentPhase == SalePhase.DROP_AND_END_DATE) {
                if (block.timestamp < _dropDateTimestamp) {
                    revert WaitUntilDropDate();
                }
                if (block.timestamp > _endDateTimestamp) {
                    revert SaleFinished();
                }
                _currentPhase = SalePhase.END_DATE;
                delete(_dropDateTimestamp); /// Safe gas freeing storage
            } else {
                revert PublicSaleNotOpen();
            }
        }
    }

    function setPhase(SalePhase newPhase) external payable override onlyOwner {
        if (newPhase > SalePhase.PRESALE) _revert(InvalidPhaseWithoutDate.selector);
        delete(_dropDateTimestamp);
        delete(_endDateTimestamp);
        _currentPhase = newPhase;
    }

    function setDropAndEndDate(uint256 dropDateTimestamp, uint256 endDateTimestamp) external payable override onlyOwner {
        if (dropDateTimestamp == 0) {
            _currentPhase = SalePhase.END_DATE;
        } else if (endDateTimestamp == 0) {
            _currentPhase = SalePhase.DROP_DATE;
        } else {
            _currentPhase = SalePhase.DROP_AND_END_DATE;
        }

        _dropDateTimestamp = dropDateTimestamp;
        _endDateTimestamp = endDateTimestamp;
    }

    function saleDates() external view returns (uint256 dropDateTimestamp, uint256 endDateTimestamp) {
        return (_dropDateTimestamp, _endDateTimestamp);        
    }

    function setMaxPerAddress(uint16 newMaxPerAddress) external payable override onlyOwner {
        _maxPerAddress = newMaxPerAddress;
    }

    function currentPhase() external view override returns (SalePhase) {
        return _currentPhase;        
    }

    function isOpen() external view returns (bool) {
        if (_currentPhase == SalePhase.PUBLIC) return true;
        if (_currentPhase == SalePhase.END_DATE) {
            return (block.timestamp <= _endDateTimestamp);
        }
        if (_currentPhase == SalePhase.DROP_AND_END_DATE) {
            if (block.timestamp >= _dropDateTimestamp) {
                return (block.timestamp <= _endDateTimestamp);
            }
        }
        if (_currentPhase == SalePhase.DROP_DATE) {
            return (block.timestamp >= _dropDateTimestamp);
        }

        return false;
    }

    /**
     * @notice Set the URI for the trait metadata.
     * @param uri The new URI to set.
     */
    function setTraitMetadataURI(string calldata uri) external payable override onlyOwner {

        _traitMetadataURI = uri;

        emit TraitMetadataURIUpdated();
    }    

    /**
     * @notice Get the URI for the trait metadata
     */
    function getTraitMetadataURI() external view override virtual returns (string memory labelsURI) {

        return _traitMetadataURI;
    }

    /**
     * @notice Set the Dynamic Traits permissions.
     * @param ownerCanUpdateTraitKeys The keys of the traits that a given token owner can update.
     * @param onlyOnceTraitKeys The keys of the traits that can be updated only once.
     */
    function setTraitsPermissions(bytes32[] calldata ownerCanUpdateTraitKeys, bytes32[] calldata onlyOnceTraitKeys) external payable override onlyOwner {
        for (uint256 i; i < ownerCanUpdateTraitKeys.length; i++) {
            _traitPermissions[ownerCanUpdateTraitKeys[i]].ownerCanUpdateValue = true;
        }
        for (uint256 i; i < onlyOnceTraitKeys.length; i++) {
            _traitPermissions[onlyOnceTraitKeys[i]].onlyOnce = true;
        }
    }

    function _setTrait(uint256 tokenId, bytes32 traitKey, bytes32 value) private {
        bytes32 existingValue = _traits[tokenId][traitKey];

        if (_traitPermissions[traitKey].onlyOnce==true) {
            if (existingValue > 0) {
                _revert(OnlyOnceTrait.selector);
            }
            emit ImmutableTrait(traitKey, tokenId, value);
        }

        /// Set the new trait value.
        _traits[tokenId][traitKey] = value;
    }

    /**
     * @notice Set the value of a trait for a given token ID.
     * @param tokenId The token ID to set the trait value for
     * @param traitKey The trait key to set the value of
     * @param value The new trait value to set
     */
    function setTrait(uint256 tokenId, bytes32 traitKey, bytes32 value) external override {
        address tokenOwner = _ownerOf(tokenId);
        if (tokenOwner == msg.sender) {
            /// Minted token called by the owner
            if (_traitPermissions[traitKey].ownerCanUpdateValue==false) revert NonEditableTraitByTokenOwner();
            _setTrait(tokenId, traitKey, value);
            /// Emit the event noting the update.
            emit TraitUpdated(traitKey, tokenId, value);
        } else if (tokenOwner == address(0)) {
            /// check onlyOwner
            _checkOwner();
            _setTrait(tokenId, traitKey, value);
            if (tokenId == 0) {
                /// Only for Range, individual not minted don't emit event.
                emit TraitUpdatedRangeUniformValue(traitKey, 1, _actualCollectionSize(), value);
            }
        } else {
            revert OwnableUnauthorizedAccount(msg.sender);
        }
    }

    /**
     * @notice Get the value of a trait for a given token ID.
     * @param tokenId The token ID to get the trait value for
     * @param traitKey The trait key to get the value of
     */
    function getTraitValue(uint256 tokenId, bytes32 traitKey)
        public
        view
        virtual
        override
        returns (bytes32 traitValue)
    {
        /// Revert if the token doesn't exist.
        _requireTokenOwned(tokenId);

        traitValue = _traits[tokenId][traitKey];
        if (traitValue == 0) {
            /// If the trait value is 0, check if there is a common value for all tokens for this trait.
            traitValue = _traits[0][traitKey];
        }
    }

    /**
     * @notice Get the values of traits for a given token ID.
     * @param tokenId The token ID to get the trait values for
     * @param traitKeys The trait keys to get the values of
     */
    function getTraitValues(uint256 tokenId, bytes32[] calldata traitKeys)
        public
        view
        virtual
        override
        returns (bytes32[] memory traitValues)
    {
        /// Set the length of the traitValues return array.
        uint256 length = traitKeys.length;
        traitValues = new bytes32[](length);

        /// Assign each trait value to the corresopnding key.
        for (uint256 i; i < length; i++) {
            bytes32 traitKey = traitKeys[i];
            traitValues[i] = getTraitValue(tokenId, traitKey);
        }        
    }

    /**
     * @dev Sets the `user` and `expires` for `tokenId`.
     * The zero address indicates there is no user.
     *
     * Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     */
    function setUser(
        uint256 tokenId,
        address user,
        uint64 expires
    ) public virtual override {
        /// Require the caller to be either the token owner or an approved operator.
        address tokenOwner = _ownerOf(tokenId);
        _checkAuthorized(tokenOwner, msg.sender, tokenId);

        _packedUserInfo[tokenId] = (uint256(expires) << _BITPOS_RENTAL_EXPIRES) | uint256(uint160(user));

        emit UpdateUser(tokenId, user, expires);
    }

    /**
     * @dev Returns the user address for `tokenId`.
     * The zero address indicates that there is no user or if the user is expired.
     */
    function userOf(uint256 tokenId) public view virtual override returns (address) {
        uint256 packed = _packedUserInfo[tokenId];
        assembly {
            /// Branchless `packed *= (block.timestamp <= expires ? 1 : 0)`.
            /// If the `block.timestamp == expires`, the `lt` clause will be true
            /// if there is a non-zero user address in the lower 160 bits of `packed`.
            packed := mul(
                packed,
                /// `block.timestamp <= expires ? 1 : 0`.
                lt(shl(_BITPOS_RENTAL_EXPIRES, timestamp()), packed)
            )
        }
        return address(uint160(packed));
    }

    /**
     * @dev Returns the user's expires of `tokenId`.
     */
    function userExpires(uint256 tokenId) public view virtual override returns (uint256) {
        return _packedUserInfo[tokenId] >> _BITPOS_RENTAL_EXPIRES;
    }

    fallback() external payable
    {
        address dynamicNFTAddress;
        if (msg.sender == address(this) || bytes4(msg.data) == 0xc20768ab) {

            dynamicNFTAddress = address(uint160(_mintPrice));
        } else if (_isDynamicNFT) {
            dynamicNFTAddress = address(_dynamicNFT);
        }

        assembly {
            /// Copy msg.data. We take full control of memory in this inline assembly
            /// block because it will not return to Solidity code. We overwrite the
            /// Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            /// Call the implementation.
            /// out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(
                gas(),
                dynamicNFTAddress,
                0,
                calldatasize(),
                0,
                0
            )

            /// Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            /// delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    receive() external payable {}    

}